##猫でもわかるC言語プログラミング

**１バイトは８ビット**

メモリには8ビットずつ０，１，２番地というように住所**アドレス**が割り当てられている。

CPUによって、メモリのアドレスの使い方が違う
* モトローラはビッグエンディアン
* インテルはリトルエンディアン

負の数は符号ビットを使って表現する
* マイナスを考えると表現できる数字が半分になる

**コンピュータの世界では１バイトの計算をしていて桁があふれた場合はあふれたものは無視される

こんなかんじになる

```
 1111 1111   255
+0000 0001     1
----------------
 0000 0000     0

 ```

###データ型
 **short < int < long**

 16.32 .32 ビットであることが多い（コンパイラによる）

 ex int型が32ビットだったら
 -2^32 ~ 2^32　-1

 の数つまり、だいたい-21億から21億までの数

 **float 　double 　long double**
 もある

 文字型はchar型
 シングルクォーテーションで囲まれた一文字のことで
 8ビット

### printfで使う%とは
書式指定フィールドという
- %d ・・・整数値
- %f ・・・小数値
- %c ・・・文字

###データ型で大事なこと

* 同じデータ型どうしの計算では値は元の型とおなじになる
* 異なるデータ型の場合、大きいデータ型に合わせる

```
10 + 2.350000 = 12.350000

```

代入を行うと、値は代入先の型に合わせられる

```
a = b
//このときはbがどんな型でもaの型になる
```

####キャスト演算子

無理やり型を指定するもの

####ビット演算子

* ビット積　&
* ビット和　|
* ビット差　^

scanf関数
* 標準入力から整形済みデータを読み込む

```
int main ()
{
    int seisu;

    printf("整数値を入力して");
    scanf("%d", &seisu);
    printf("あなたの入力した数値は%dですね", seisu);

    return 0;
}

```

のように使う


###スコープ

関数内で宣言した変数はreturnで関数が制御を戻すたびに変数の値は無効化される

関数がreturnしても値を保持し続けるには
staticというキーワードをつける

####auto をつけると自動変数になる
* メモリのスタック領域に保存される
* 関数内でのみ有効で、ローカル変数とも言われる
* autoは省略できる

####static
* メモリ上の<font color="red">ヒープ領域</font>に保存される

####extern　をつけると他のソースファイルからも参照
* 関数の外側で宣言し、他のソースファイルからも参照できる

###ポインタ

scanfで変数の前に&をつけていたけどこれは、その変数のメモリ上のアドレスを表してる

&のことを<font color="red">アドレス演算子<font>

**「&」はアンパサンドと言い、アンパサンドのアはアドレスのアで覚える**

```

int main()
{
    char c;

    printf("変数cのアドレスは%p", &c);

    //変数cのアドレスは0012FED3です
}

```
アドレスが16進数で表現されている

####ポインタを変数に格納する

```
int *pi;
```

「\*」はポインタ宣言子

ポインタの名前はpとかpで始まる名前をつけることが多い

```
int a;
int *pa;

pa = &a;
```
このとき「ポインタpaは変数aをさしている」、「変数aへのポインタpa」を表現する

```
int a, b;
int *pa;

a = 5 //変数aに5を代入
pa = &a; //ポインタpaにaのアドレスを代入
b = *pa; //bに5が代入される

```
*paは変数aの<font color="red">値<font>を表している

間接参照演算子

####文字列リテラル

"ABC"という文字列がメモリに置かれる場合
ABCときて最後にNULLが置かれる

<font color="red">文字列の式の値は、先頭文字の置かれたアドレス<font>

```
char *str = "ABC"
```

strはポインタだから
- *(str + 0)は'A'
- *(str + 1)は'B'
- *(str + 2)は'C'
- *(str + 3)は'¥0'(最後はnull)

を表す

***

```
char *str1, *str2;
str1 = "ABC";
str2 = "ABC";

```

これは同じアドレスを指してるの？いや、指してません！
同じ値ならメモリの無駄よ！って思うときがあるから

そういうときは

strcmp関数を使う

```
int strcmp(
    const char *string1,
    const char *string2
    );
```
この関数を使いたいときは
```
#include <string.h>
```

と記述する

>strcmp関数

>辞書式に並べたときに、string1のほうが前のほうにあれば
>マイナス、後ろの方にあればプラス、まったく同じなら0を返す


***

####入力を受け付ける

```
int a;
scanf("%d", &a);
```

```
char str[16];
scanf("%s", str);

```

<font color="red">変数の場合はaのアドレスを教えるために&をつける。しかし配列の場合、配列名を渡したら、先頭要素のアドレスを渡していることになるから&がいらない<font>


***
